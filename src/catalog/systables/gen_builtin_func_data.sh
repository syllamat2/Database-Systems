#!/bin/bash

if [ $# -lt 2 ]; then
    echo "usage: <outdir> <list_of_files...>"
    exit 1
fi

BASEDIR="$(realpath "`dirname "$0"`")"
cd "$BASEDIR"

OUTDIR="$1"
SRCDIR=../..

shift

CXX="${CXX-c++} -I../../../include -I$OUTDIR/../.. -I$OUTDIR"
PYTHON3=${PYTHON3-python3}

if [ ! -d "$OUTDIR" ]; then
    mkdir -p "$OUTDIR"
fi

# We also keep the #if and #endif derivatives, but only includes config.h so
# these files must not use definitions that are not available through config.h.
ALL_BUILTIN_DEFFILE=`mktemp`
cat $@ | \
    grep "^\(BUILTIN_RETTYPE\|BUILTIN_FUNC\|BUILTIN_ARGTYPE\|BUILTIN_OPR\|[#]if\|[#]endif\)" > "$ALL_BUILTIN_DEFFILE"

echo "create FunctionMapping.py.inc"
echo "
#include \"config.h\"
#define INCLUDE_MACROS_ONLY
#include \"utils/misc.h\"
#define BUILTIN_RETTYPE(...)
#define BUILTIN_FUNC(funcname, ...) funcname = CAR(__VA_ARGS__)
#define BUILTIN_ARGTYPE(...)
#define BUILTIN_OPR(...)

_COMMENT The mapping data file from funcname to funcid for builtin functions.
_COMMENT This is a file to be included into a python file using a C/C++
_COMMENT preprocessor.
_COMMENT This data file is automatically generated, do NOT modify.
_EMPTYLINE

#include \""$ALL_BUILTIN_DEFFILE"\"

" | $CXX -E - | \
    grep -v "^#" | grep -v "^$" | \
    sed -e "s/^_COMMENT/\/\//" -e "s/^_EMPTYLINE$//" \
    > "${OUTDIR}/FunctionMapping.py.inc"
[ $? -ne 0 ] && exit $?

echo "create Function.dat, FunctionArgs.dat and Operators.dat"
echo "
#include \"config.h\"
#define INCLUDE_MACROS_ONLY
#include \"utils/misc.h\"
#include \"utils/macro_map.h\"

#include \"init_systable_gen.py.inc\"

#define TABLEDEF \"Function.inc\"
#include \"load_table.py.inc\"

#define OPTYPE_CONSTANT_ONLY
#include \"query/expr/optypes.h\"

#define BUILTIN_RETTYPE(ret_type) }, {\
    funcrettypid: parse_arg_type(STRINGIFY(ret_type)),
#define BUILTIN_FUNC(_1, ...) \
    funcid: CAR(__VA_ARGS__), \
    funcname: STRINGIFY(_1),
#define PARSE_ARG_TYPE(v) parse_arg_type(STRINGIFY(v))
#define BUILTIN_ARGTYPE(...) \
    'funcargs': [ MAP_LIST(PARSE_ARG_TYPE, __VA_ARGS__) ],
#define BUILTIN_OPR(...) \
    'optypes': [ MAP_LIST(OPTYPE, __VA_ARGS__) ],

print('// Data file for the Function catalog')
print('// This is a file to be included into a python file using a C/C++')
print('// preprocessor.')
print('// This file is automatically generated, do NOT modify.')

argsout = open('""${OUTDIR}""/FunctionArgs.dat', 'w')
argsout.write('// Data file for the FunctionArgs catalog\n')
argsout.write('// This is a file to be included into a python file using a C/C++\n')
argsout.write('// preprocessor.')
argsout.write('// This file is automatically generated, do NOT modify.')

opout = open('""${OUTDIR}""/Operator.dat', 'w')
opout.write('// Data file for the Operator catalog\n')
opout.write('// This is a file to be included into a python file using a C/C++\n')
opout.write('// preprocessor.')
opout.write('// This file is automatically generated, do NOT modify.')

def parse_arg_type(typname_):
    typname_ = typname_
    if typname_ in typname2idx:
        idx = typname2idx[typname_]
        return typlist[idx][typid]
    else:
        print('Error: unable to find type', typname_, file=sys.stderr)
        sys.exit(1)

func_list = [ {
#include \""$ALL_BUILTIN_DEFFILE"\"
}
]
func_list = func_list[1:]

for func in func_list:
    print()
    print('{')
    print('    funcid: {}, funcnargs: {}, funcrettypid: {},'.format(
        func[funcid], len(func[\"funcargs\"]), func[funcrettypid]))
    print('    funcname: \"{}\"'.format(func[funcname]))
    print('},')
    funcargid = 0
    for funcargtypid in func[\"funcargs\"]:
        argsout.write('\n{{\n    funcid: {}, funcargid: {}, funcargtypid: {}\n}},\n'.format(
            func[funcid], funcargid, funcargtypid))
        funcargid += 1
    if 'optypes' in func:
        for optype in func['optypes']:
            opout.write('\n{{\n    optype: {}, opfuncid: {}, oparg0typid: {}, oparg1typid: {}\n}},\n'.format(
                optype, func[funcid], (len(func['funcargs']) > 0 and func['funcargs'][0] or 0),
                (len(func['funcargs']) > 1 and func['funcargs'][1] or 0)))
argsout.close()
opout.close()

" | $CXX -E - | ${PYTHON3} \
    > "${OUTDIR}/Function.dat"
[ $? -ne 0 ] && exit $?

echo "create builtin_func_table.h"
echo \
'
#ifndef CATALOG_SYSTABLE_BUILTIN_FUNC_TABLE_H
#define CATALOG_SYSTABLE_BUILTIN_FUNC_TABLE_H

#include "tdb.h"

namespace taco {

constexpr uint32_t num_builtin_funcs = '\
$(grep '=' "${OUTDIR}/FunctionMapping.py.inc" | wc -l)';

extern std::pair<Oid, FunctionPtr> builtin_func_table[num_builtin_funcs];

}   // namespace taco

#endif      //CATALOG_SYSTABLE_BUILTIN_FUNC_TABLE_H
' > "${OUTDIR}/builtin_func_table.h"
[ $? -ne 0 ] && exit $?

echo "create builtin_func_table.cpp"
echo \
'
#include "init_systable_gen.py.inc"

#define TABLEDEF "Function.inc"
#define TABLEDATA "Function.dat"
#include "load_table.py.inc"

print('"'"'#include "catalog/systables/builtin_func_table.h"'"'"')
print()
print('"'"'namespace taco {'"'"')
print()
for d in datalist:
    print('"'"'Datum {}(FMGR_FUNCTION_ARGS);'"'"'.format(d[funcname]))
print()
print('"'"'std::pair<Oid, FunctionPtr> builtin_func_table[] = {'"'"')
for d in datalist:
    print('"'"'    {{{}, {}}},'"'"'.format(d[funcid], d[funcname]))
print('"'"'};'"'"')
print()
print('"'"'}    // namespace taco'"'"')
' | $CXX -E ${INCLUDE} -I${OUTDIR} - | ${PYTHON3} \
    > "${OUTDIR}/builtin_func_table.cpp"
[ $? -ne 0 ] && exit $?

rm -f "$ALL_BUILTIN_DEFFILE"
    
